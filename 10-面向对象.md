1. JavaScript是通过prototype属性实现继承的，继承的属性方法是共享的，例如Child子类继承Parent父类，Child.prototype = new Parent（）；
   在子类构造函数内执行父类构造函数，并传递子类作用域和参数，从而实现对父类构造函数的继承，例如

   ```javascript
   function Child() {
     Parent.apply(this, arguments)
   }
   ```

2. 创建一个新的对象，这个对象的类型是Object

   将this指向这个该实例对象

   将实例对象的原型指向该构造函数的原型

   执行构造函数，通过this对象，为实例化对象添加自身属性方法

   将this引用的新创建的对象返回

   ```javascript
   function () {
     var obj = {};
     obj.__proto__ = Base.prototype;
     School.call(obj);
     return obj;
   }
   ```

3. 子类的实例可以共享父类的方法；子类可以覆盖父类扩展来的方法。

4. 构造函数的函数名首字母大写，构造函数类似于一个模板，可以使用new关键字执行构造函数，创建实例化对象。

5. we

6. we

7. - 构造函数继承是指在子类的作用域上，执行父类的构造函数，并传递参数。构造函数式继承虽然解决了对父类构造函数的复用问题，但是没有更改原型。
     - 构造函数式继承中，属性的赋值一定在继承的后面执行否则会产生覆盖问题。

   - 类(原型式)继承是指将父类的实例化对象添加给子类的原型。执行构造函数是没有意义的，因为指向继承原型链上的属性和方法，当执行父类的构造函数时，没有添加参数，所以执行构造函数的结果是不正确的。父类构造函数中的数据，没有直接添加在子类的实例化对象上，而是添加在原型上。子类型实例化时无法复用父类的构造函数。
     - 原型上属性或方法的赋值一定在继承后面，否则会产生覆盖问题。
     - 在原型上添加属性或者方法一定使用点语法的形式，不可以给对象赋值。
     - 要为原型添加属性方法对象，可以在继承后面通过库的extend方法(es6)
   - 组合继承是比较常用的继承方法，其背后思路是，使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。这样，既在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。但其问题是导致父类的构造函数执行了两次：一次在构造函数式的继承中执行的；另一次是在类式继承中执行的。

8. 

   